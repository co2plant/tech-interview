# DB 쿼리

<br>

## 목차
1. [DB 쿼리란?](#db-쿼리란)
2. [DB 쿼리 종류](#db-쿼리-종류)
3. [DML](#dml)
4. [SELECT문](#select문)
5. [SQL절 실행 순서](#sql절-실행-순서)
6. [WHERE vs HAVING](#where-vs-having)
7. [GROUP BY](#group-by)
8. [윈도우 함수](#윈도우-함수)
9. [EXISTS vs IN](#exists-vs-in)
10. [LIKE](#like)

<br>

## DB 쿼리란?

Query = 질문, 질문하다

- **Database Query**
    - 데이터베이스에 `원하는 정보를 얻기 위해` 특정 언어 (주로 SQL)로 `작성된 질문`
    - 데이터베이스에 삽입, 수정 등 다양한 작업을 요청하는 명령문, 질의문

- **SQL**
    - 가장 널리 쓰이는 Database Query 언어
    - `Database Query를 표현하기 위한` 구체적인 언어 중 하나
    - 대부분 RDB는 SQL로 쿼리 작성
    - RDB에서 데이터 관리, 조작하는데 사용되는 `표준 프로그래밍 언어`

<br>

## DB 쿼리 종류

- **DDL (Data Definition Language, 데이터 정의어)**
    
    데이터베이스의 `구조(테이블, 컬럼 등)를 생성, 수정, 삭제`하는 명령어
    
    - 예: CREATE, ALTER, DROP, TRUNCATE, RENAME

- **DML (Data Manipulation Language, 데이터 조작어)**
    
    데이터베이스 안의 `실제 데이터를 조회, 삽입, 수정, 삭제`하는 명령어
    
    - 예: SELECT, INSERT, UPDATE, DELETE

- **DCL (Data Control Language, 데이터 제어어)**
    
    사용자 권한과 같은 `접근 권한을 제어`하는 명령어
    
    - 예: GRANT, REVOKE

- **TCL (Transaction Control Language, 트랜잭션 제어어)**
    
    여러 데이터 작업을 `하나의 일괄적인 처리로 관리 및 제어`하는 명령어
    
    - 예: COMMIT, ROLLBACK, SAVEPOINT

<br>

## DML

데이터베이스 내에서 데이터를 조회, 삽입, 수정, 삭제하는 작업을 수행하는 명령어

데이터베이스에 저장된 데이터를 조작하기 위해 사용

<br>

### 대표적인 SQL 명령어

- **`SELECT`**
    - 데이터베이스 테이블에서 원하는 데이터 조회 및 검색
        
        - 기본 구조
            
            ```sql
            SELECT 컬럼명1, 컬럼명2 FROM 테이블명 WHERE 조건;
            ```
            
- **`INSERT`**
    - 데이터베이스 테이블에 새로운 데이터 추가
        
        - 기본 구조
            
            ```sql
            INSERT INTO 테이블명 (컬럼1, 컬럼2) VALUES (값1, 값2);
            ```
            
        - 모든 컬럼에 값 넣을 경우 컬럼명 생략 가능
        - VALUES 뒤에 ,로 여러 행 삽입 가능
- **`UPDATE`**
    - 데이터베이스 테이블의 기존 데이터를 수정
        
        - 기본 구조
            
            ```sql
            UPDATE 테이블명 SET 컬럼1=값1, 컬럼2=값2 WHERE 조건;
            ```
            
        - WHERE 조건으로 단일 행, 여러 행 수정 가능
        - WHERE절 없이 UPDATE 실행 시 모든 행 수정됨
- **`DELETE`**
    - 데이터베이스 테이블에서 데이터를 삭제
        
        - 기본 구조
            
            ```sql
            DELETE FROM 테이블명 WHERE 조건;
            ```
            
        - WHERE 조건으로 단일 행, 여러 행 삭제 가능
        - WHERE절 없이 DELETE 실행하면 테이블의 모든 데이터 삭제됨.

<br>

### 각 명령어 사용 시 주의 사항

- **SELECT 사용 시 주의사항**
    - **WHERE 조건 생략 시**
        - 데이터 전체 조회되어 성능 저하 or 불필요한 정보 노출 위험 있음
    - **INDEX 활용**
        - 대량의 데이터에서 효율적으로 조회 방법 = INDEX가 설정된 컬럼 WHERE, ORDER BY 등에 적극 활용
    - **컬럼 지정**
        - SELECT * 형태 대신 실제 필요한 컬럼만 명시 해야 함
        - 네트워크 트래픽 및 서버 부하 줄이기 위함
    - **민감정보 노출 주의**
        - 개인정보, 비밀 데이터가 필요 이상으로 조회되지 않도록 주의
    - **성능 저하 유발 연산 주의**
        - 아래의 것은 전체 테이블 스캔을 유발할 수 있어 성능 주의해야 함
        - JOIN, 서브쿼리, GROUP BY, ORDER BY, LIKE '%검색어%' 등

- **INSERT 사용 시 주의사항**
    - **컬럼 일관성**
        - INSERT 시 컬럼 순서, 데이터 타입, 제약 조건 맞춰야 함
        - 잘못하면 에러 또는 데이터 무결성 문제 발생
    - **중복 데이터 주의**
        - PRIMARY KEY, UNIQUE 같은 제약 있는 컬럼에 중복 데이터 삽입되지 않게 유의
    - **트랜잭션 단위**
        - 대량 INSERT 시, 중간에 실패할 수 있음
        - 이때 전체 작업 한 번에 ROLLBACK 할 수 있게 트랜잭션 처리 권장
    - **외래키 제약 조건**
        - 외래키가 있는 경우 참조하는 데이터가 이미 존재해야 함
    - **대량 삽입 시 부하**
        - BATCH INSERT, BULK INSERT, 임시 테이블 활용 등을 고려
        - 부하가 적은 시간에 실행

- **UPDATE 사용 시 주의 사항**
    - **WHERE 조건 필수**
        - WHERE 조건이 없으면 모든 데이터가 변경됨
    - **대상 확인**
        - UPDATE 전에 SELECT로 대상 데이터가 정확한지 미리 확인
    - **동시 갱신 주의**
        - 여러 사용자가 동시에 데이터 수정할 경우, 동시성 제어나 Lock 전략이 필요
    - **트랜잭션 활용**
        - 실수로 인한 전체 데이터 수정 등 복구하려면 COMMIT/ROLLBACK을 적절히 사용
    - **값 누락, 타입 혼동 주의**
        - NULL, Data Type, 논리 오류 등 잘못된 값으로 업데이트 되는지 확인 필요

- **DELETE 사용 시 주의 사항**
    - **WHERE 조건 필수**
        - WHERE절 누락 시 모든 데이터가 삭제됨
    - **안전 조치**
        - 중대한 DELETE는 먼저 SELECT로 내용을 확인
        - 또는 트랜잭션으로 묶어서 검증 후 COMMIT
    - **연관 데이터 영향**
        - 외래키로 연결된 다른 테이블에서 연쇄 삭제가 발생할 수 있음
        - 삭제 전에 반드시 관련 데이터도 고려
    - **복구 방안**
        - 잘못 삭제 시 데이터를 복원할 수 있는 백업, 로그 존재여부 확인
    - **대량 삭제 시 부하**
        - 대량 데이터 삭제는 DB 부하를 유발
        - 분할 삭제, 적정 시간대 실행 등을 고민

<br>

## SELECT문

### SELECT문 형식

```sql
SELECT [PREDICATE] [테이블명.] 속성명 [AS 별칭] [, [테이블명.] 속성명, ...]
									 [, 그룹 함수(속성명) [AS 별칭]]
									 [, WINDOW 함수 OVER (PARTITION BY 속성명1, 속성명2, ...]
FROM 테이블명[, 테이블명, ... , [JOIN 테이블명]]
[WHERE 조건1 [조건 연산자 조건2 ...]]
[GROUP BY 속성명1, 속성명2, ...]
[HAVING 조건] 
[ORDER BY 속성명 [ASC | DESC]];
```

- **`PREDICATE`**
    - 불러올 튜플 수 제한하는 명령어 작성하는 곳
    
    - ALL, DISTINCT, DISTINCTROW 중 하나
      - **ALL**
          - 모든 튜플 검색할 때 지정, 주로 생략
      - **DISTINCT**
          - 중복 튜플 있다면 그 중 첫번째 한 개만 검색
      - **DISTINCTROW**
          - 행 전체의 모든 튜플이 중복된 경우 제거하고 한 개만 검색
          - 주로 JOIN, 복합 조회 시 사용
          - 일부 DBMS에서만 지원, 표준 SQL에는 없음

- **`속성명`**
    - **가능한 것**
        - 검색해 불러올 속성
        - 속성 이용한 수식
    
    - 테이블 모든 속성 지정 시 * 사용
    
    - FROM에 테이블 여러 개일 때 중복 속성명 존재 가능
        - ‘테이블명.속성명’ 으로 표현

- **`AS`**
    - 속성명 뒤에 사용
    - 속성명을 다른 별칭으로 표시하기 위해 사용

- **`FROM`**
    - SELECT문에 의해 검색될 데이터 지정 = 어떤 테이블에서 데이터 가져올지 지정
    
    - 반드시 테이블 구조 가지는 것 와야 함 (단일 값, 배열 등 올 수 없음)
    
    - **가능한 것**
        - 테이블
            - DB에 등록된 테이블명 지정
        - 뷰
            - DB에 등록된 가상 테이블 = 뷰 지정 가능
        - 서브 쿼리
            - 또 다른 SELECT문 = 결과가 테이블
            - 서브 쿼리를 마치 임시 테이블처럼 지정 가능
            - 별칭 반드시 필요 (서브 쿼리의 결과 테이블에 붙일 이름)
            - FROM (SELECT * FROM users WHERE age > 20) AS sub
        - JOIN
            - 여러 테이블과 JOIN한 결과도 테이블

- **`WHERE`**
    - 원하는 데이터만 선택해 결과로 반환하기 위해 조건 명시하는 부분
    
    - **가능한 것**
        - `비교 연산자`
            - =, !=, >, <, >=, <=
        - `논리 연산자`
            - AND, OR, NOT
        - `범위 조건`
            - BETWEEN A AND B
            - 값이 A와 B 사이에 있는지?
            - A, B로 비교 가능한 값 (숫자, 문자열 등) 옴
        - `목록 조건`
            - IN (값1, 값2, …)
            - 값이 목록에 포함되어 있는지?
        - `EXISTS`
            - EXISTS (서브 쿼리)
            - 서브 쿼리에 결과가 존재하는지?
            - 서브 쿼리에 결과 행이 하나라도 존재하면 TRUE
            - 보통 메인 쿼리의 컬럼과 비교하는 조건 써서 사용
                - 메인 쿼리의 컬럼이 다른 테이블에 존재하는지 판단하는 것
                - 다른 테이블에 존재하는 컬럼만 출력하는 느낌
            - EXISTS, NOT EXISTS, CASE WHEN EXISTS(…) THEN … ELSE … END
        - `패턴 매칭`
            - LIKE 연산자 사용
            - 와일드카드를 이용해 지정된 속성의 값이 문자 패턴과 일치하는 튜플 검색 위해 사용
            - 와일드카드

                | 와일드카드 | 의미           |
                | ---------- | -------------- |
                | %          | 모든 문자 대표 |
                | _          | 문자 하나 대표 |
                | #          | 숫자 하나 대표 |
        - `NULL 검사`
            - 속성의 NULL 값 여부 검사
            - IS NULL, IS NOT NULL
        - `함수 사용`
            - 함수 결과를 조건으로 사용 가능
            - 문자열 함수, 숫자 함수, 날짜/시간 함수, NULL 관련 함수, 논리 및 기타 함수

- **`GROUP BY`**
    - **개념**
        - GROUP BY에 명시한 속성을 기준으로 데이터를 묶어 그룹화 해서 검색할 때 사용함
        - 여러 속성 중 같은 값을 갖는 속성들을 하나의 그룹으로 묶음
        - 그룹 함수 = 집계 함수와 함께 사용함
    
    - **특징**
        - SELECT절에는 반드시 GROUP BY에 명시된 속성 or 집계 함수 결과만 올 수 있음
        - 여러 속성을 동시에 그룹화할 수 있음
        - 그룹화된 각 그룹에 대해 하나의 행이 결과로 출력됨
        - 성능에 영향 줄 수 있으므로 적절한 인덱스 사용과 주의 필요

- **`HAVING`**
    - **개념**
        - GROUP BY와 함께 사용됨
        - 그룹화된 데이터에 조건을 걸 때 사용함
        - GROUP BY로 묶은 결과에 대해 특정 조건을 필터링할 때 사용
    
    - **가능한 것**
        - 집계 함수
            - HAVING COUNT(*) > 5
        
        - 별칭
            - GROUP BY, SELECT절에서 정의한 별칭도 조건에 활용 가능
            - 예시
                
                ```sql
                SELECT customer_id, SUM(order_total) AS total_order
                FROM orders
                GROUP BY customer_id
                HAVING SUM(order_total) > 200 AND customer_id IN (101, 102)
                ```
                
        - WHERE절의 것들
            - WHERE처럼 비교, 논리 연산자, LIKE, IN 등 사용 가능

- **`ORDER BY`**
    - SELECT 쿼리 결과를 ORDER BY 뒤에 작성한 속성 기준으로 정렬할 때 사용함
    - 한 열 or 여러 열 기준으로 정렬 가능
    - **가능한 것**
        - ASC = 오름차순, default라 생략 시 오름차순 적용
        - DESC = 내림차순
   
    - **속성명으로 가능한 것**
        - 집계 함수
        - 표현식
        - SELECT절의 별칭
        - 컬럼 위치 번호
            - ex : ORDER BY 2 = 두번째 컬럼의 속성 기준
    
    - **주의할 점**
        - NULL 값 처리
            - 데이터베이스마다 NULL의 정렬 위치(앞/뒤)가 다를 수 있음.
            - 필요하면 NULLS FIRST/LAST 등을 명시.
        - 컬럼 위치 번호 사용 시
            - SELECT 리스트 바뀌면 (컬럼 순서 바뀌면) 결과 달라질 수 있음
            - 따라서 컬럼 이름으로 지정하는게 안전
        - 집계 함수, GROUP BY와 함께 사용 시
            - 결과를 요약한 뒤 정렬해 원하는 데이터 맞는지 확인해야 함

- **`LIMIT`**
    - **개념**
        - 쿼리 결과에서 반환되는 행 개수 제한할 때 사용
        - 조회 결과 중 일부만 보고 싶을 때 활용
        - MySQL, PostgreSQL 등에서 사용 가능 but 표준 SQL에는 포함 X
    
    - **사용 방법**
        - SELECT 쿼리 마지막에 사용
        - ORDER BY와 조합해 상위, 하위 N개 등 원하는 부분만 추출 가능
        - 페이징 등에 사용
    
    - **가능한 문법**
        - 단일 숫자
            - `LIMIT 5`
            - 앞에서부터 5행
        
        - 시작행, 숫자
            - **`LIMIT 3, 4`**
            - INDEX 3부터 4행 = 4~7번째 행
            - 1번째 행이 INDEX 0 느낌
        
        - OFFSET
            - **`LIMIT 4 OFFSET 3`**
            - INDEX 3부터 4행 = 4~7번째 행
    
    - **주의할 점**
        - 대용량 데이터에서 OFFSET 사용 시 속도 저하
            - OFFSET 값이 커질수록 속도 저하 발생
            - OFFSET이 지정한 행 수만큼 데이터를 모두 읽고 버리기 때문
            - key/인덱스 활용 등 대안 고려
       
        - NULL 포함 및 중복 주의
            - 원하는 결과 정확히 얻으려면 명확한 ORDER BY와 함께 사용

<br>

## SQL절 실행 순서

SQL 쿼리 실행 순서는 **`표면적으로 쿼리 작성 순서와 다르다`**.

데이터 처리 및 최적화를 위해 특정 단계 순서로 실행된다.

<br>

### 순서

1. **`FROM, ON, JOIN`**
    1. FROM
        1. 데이터를 가져올 테이블 결정
    2. ON 
        1. JOIN 조건을 확인
    3. JOIN 
        1. JOIN을 통해 가상 테이블을 만듬
2. **`WHERE`**
    1. FROM에서 가져온 행들에 WHERE 조건이 개별 행에 적용됨
    2. 조건에 맞는 행만 필터링하는 행 단위 필터링, 집계 전 필터링
3. **`GROUP BY`**
    1. WHERE 조건 통과한 행들을 GROUP BY에 지정된 열을 기준으로 그룹화 됨
    2. 집계 함수를 적용할 준비함
4. **`HAVING`**
    1. GROUP BY로 그룹화된 행에 HAVING의 제약 조건이 적용되어 필터링
5. **`SELECT`** 
    1. 화면에 출력할 컬럼을 선택, 계산
    2. 별칭 지정 시 이 시점부터 유효
6. **`DISTINCT`**
    1. 중복된 결과 행을 제거
7. `ORDER BY`
    1. 결과 행들을 지정한 컬럼 기준으로 오름차순 or 내림차순 정렬
8. **`LIMIT, OFFSET`**
    1. 결과 행 수를 제한 또는 특정 위치부터 출력

<br>

### 왜 쿼리 작성 순서와 실행 순서가 다른가?

- **`논리적 데이터 처리 흐름`**
    - 이 순서가 논리적으로 자연스러운 순서
        - FROM으로 데이터 가져오고→ WHERE로 필요한 데이터만 고르고 …
    
    - GROUP BY → HAVING 이유
        - 먼저 그룹화 되어야 집계 후 조건 적용할 수 있기 때문
    
    - → SELECT → DISTINCT → ORDER BY → LIMIT 이유
        - 출력할 컬럼이 정해지고 결과를 정렬하고 제한 가능하기 때문
- **`최적화 효율성`**
    - WHERE 같은 필터를 먼저 적용하면 데이터가 적어침
   
    - 이후 단계의 처리량이 줄어들어 성능 향상에 도움됨

<br>

## WHERE vs HAVING

### 사용 시점 및 차이점

- **`WHERE`**
    - 데이터베이스 테이블에서 그룹화 (GROUP BY) 전에 행 단위 조건을 걸어 행을 필터링할 때 사용
    
    - 집계 함수 사용 불가능
    
    - 행 단위 조건, 그룹화 전 필터링
- **`HAVING`**
    - GROUP BY 후 그룹화한 결과에 조건을 걸어 필터링할 때 사용
    
    - 그룹별로 집계된 결과 값을 다시 필터링해야 할 때 사용
    
    - 집계 함수 사용 가능
    
    - 그룹화 결과에 조건, 그룹화 후 필터링

<br>

### 성능 관련

- **`WHERE만 사용해 조건을 걸 때`**
    - 원본 테이블의 행을 먼저 거르고 필터링된 데이터만 다음 단계로 넘어감
    - 불필요한 데이터 처리량을 사전에 줄일 수 있음
    - INDEX를 적극적으로 사용할 수 있음
    
        - WHERE절 조건은 쿼리 플랜에서 먼저 필터링 됨
        - 해당 컬럼에 INDEX 있으면 빠르게 조건에 맞는 데이터만 읽어올 수 있음

- **`HAVING만 사용해 조건을 걸 때`**
    - 모든 데이터를 먼저 그룹핑, 집계 후 그 집계 결과에 조건을 검
    - 필요 없는 데이터까지 그룹핑하고 연산해 불필요한 계산 많이 일어남
    - 인덱스를 충분히 활용하지 못하는 상황도 종종 생김
    
        - 집계까지 마친 후 필터가 적용됨
        - GROUP BY, 집계 함수 사용되면 데이터가 원래 테이블 형태에서 바뀜
        - 기존 테이블 기준으로 만든 INDEX 사용 못하게 됨

<br>

### 어떻게 해야 성능을 올릴 수 있는지?

- **`행 단위, 원본 테이블 관한 조건은 항상 WHERE에 넣자`**
    - WHERE절에 조건을 최대한 많이 넣자.
    - WHERE로 먼저 거를 수 있으면 WHERE에서 필터링 우선 적용하자.

- **`집계값, 그룹 결과 관한 조건만 HAVING에 넣자`**

- **`WHERE에 올 수 있는 조건을 HAVING에 두지말자.`**
    - 집계 결과와 무관한 그냥 조건을 HAVING에 두면 불필요하게 모든 행을 그룹핑 해서 성능이 떨어진다.

where vs on도 있지만 join과 관련된 것이라 join 파트에서 보자. 

<br>

## GROUP BY

### 집계함수란?

여러 행의 데이터 집합에서 합계, 평균 등과 같은 요약된 **단일 결과값을 반환하는 함수**

주로 **GROUP BY절과 함께 사용**됨

특정 집계 결과를 계산하는데 사용됨

<br>

### 성능에 영향 주는 이유?

- **`대량의 데이터 정렬 및 그룹화 처리`**
    - 그룹화 기준 컬럼 기준으로 데이터 그룹화하고 정렬하는 작업 수행
    - 데이터 많으면 정렬과 그룹화 작업이 무거워져 자원 많이 사용

- **`INDEX 미활용 시 전체 테이블 스캔`**
    - 대상 컬럼에 적절한 INDEX 없으면 전체 테이블 스캔
    - 행들 그룹화 해야 하기 때문에 행들 읽어야 함
    - 그 후 임시 테이블에 담아 데이터 정렬 및 그룹화 처리
    - 상당한 부하가 걸림

- **`임시 테이블과 디스크 IO 과다`**
    - 메모리 또는 디스크의 임시 저장공간을 활용해 임시 테이블 생성
    - 메모리 한계 초과하면 임시 테이블이 디스크에 생성
    - 디스크 IO로 쿼리 매우 느려질 수 있음

- **`복잡한 집계, 함수, 조인`**
    - GROUP BY에 함수나 계산식 들어갈 경우 INDEX 무효화 됨
        - 함수, 계산식 적용 시 먼저 실행됨
        - INDEX는 원본 값을 기반으로 정렬되어 있음
        - 함수, 계산식 적용 후 값 달라져 INDEX 활용 불가능
    - 따라서 쿼리 실행 시간 늘어남

<br>

### 주의해야 할 점 및 성능 저하 원인

- **`GROUP BY 컬럼에 INDEX 없음`**

- **`불필요하게 많은 컬럼으로 GROUP BY`**
    - 그룹 수 대폭 증가 (메모리 사용량 증가로 인한 성능 저하 발생 가능)
    - 메모리 부족과 디스크 IO 발생 가능성 커집

- **`불필요한 집합 함수, DISTINCT, HAVING 남발`**
    - 집합 함수 : 여러 행 요약하는 작업이라 많은 연산 필요
    - DISTINCT : 중복 행 제거 위해 데이터 정렬, 해시 처리 수행
    - HAVING : 먼저 전체 그룹화 수행 후 필터링해 작업량 많음

- **`LIKE, 함수, 계산식, 부정 조건, 자료형 변환 등 INDEX 활용 불가 조건 사용`**
    - 데이터 달라져 INDEX 활용 불가능해짐
    - 부정 조건이나 자료형 맞지 많아 변환 일어나도 INDEX 적용 안됨

- **`NULL 값 그룹핑, 다중컬럼 그룹핑`**
    - NULL 값은 NULL끼리 그룹핑 되어 NULL 포함 컬럼은 의도치 않은 NULL 그룹 생성될 수 있음
    - 여러 컬럼 그룹핑 시 컬럼 순서, 복합 INDEX 순서가 성능에 영향 미침

<br>

### 성능 개선 방법

- **`INDEX 활용 최적화`**
    - GROUP BY 컬럼에 INDEX 두기
        - INDEX 자체 정렬을 활용해 GROUP BY 처리를 더 빠르게 수행 가능
    - 컬럼 여러 개인 경우 모두 적절한 인덱스 생성
        - 복합 INDEX 순서와 GROUP BY 컬럼 순서 일치하면 성능 향상 가능

- **`쿼리 구조 개선`**
    - GROUP BY 전에 WHERE로 데이터 최대한 필터링
        - 불필요한 데이터 제거
    - JOIN 전에 서브 쿼리 등으로 미리 집계
        - JOIN 대상 행 수 줄이기

- **`컬럼 관련`**
    - GROUP BY 컬럼, 순서 조정
        - 복합 INDEX 순서와 맞으면 Loose Index Scan 등 고성능 처리 가능
    - 함수나 계산식 GROUP BY 컬럼에 사용 x
        - INDEX 무효화 피하기

<br>

## 윈도우 함수

### 윈도우 함수란?

원본 행 수를 유지하며 전체 결과 or 그룹 내 **각 행에 계산 수행하는 함수**

<br>

### 윈도우 함수 vs 집계 함수, GROUP BY

---

- 집계 함수
    - 그룹화된 데이터에 대해 하나의 값 반환

- 윈도우 함수
    - 전체 결과 or PARTITION으로 나눈 그룹 내 각 행에 대해 계산된 값 반환
    - 기존의 집계함수를 윈도우 함수로 사용하면, 그룹별 합계를 행별로도 제공 가능

<br>

---

<br>

- GROUP BY
    - 그룹핑해 집계한 결과 반환
    - 행을 그룹별로 줄임
    - SELECT 결과 자체를 집계해서 반환
- 윈도우 함수
    - 각 행에 집계 등의 계산 결과 추가
    - 원본 행 수 유지
    - SELECT한 결과의 각 행에 추가 정보 부여

---

<br>

### 윈도우 함수 기본 문법 예시

```sql
SELECT column1,
       SUM(column2) OVER (PARTITION BY column3 ORDER BY column4) AS running_total,
       RANK() OVER (PARTITION BY column3 ORDER BY column2 DESC) AS rank_in_group
FROM table_name;
```

<br>

- **`OVER 절 필수`**
    - OVER에 아래의 것들 지정
        - PARTITION BY : 행을 나누는 기준, 행의 값별로 소그룹으로 나눔
        - ORDER BY : 정렬 기준

- **`OVER 앞에 다양한 함수`**
    - **그룹 내 순위 함수**
        - 특정 그룹 내 순위 계산 함수
        - RANK, DENSE_RANK, ROW_NUMBER
    - **그룹 내 집계 함수**
        - 기존 집계 함수 확장한 함수
        - SUM, MAX, MIN, AVG, COUNT
    - **그룹 내 행 순서 함수**
        - 그룹 내 행의 상대적 위치 값 참조 함수
        - FIRST_VALUE, LAST_VALUE, LAG, LEAD
    - **그룹 내 비율 함수**
        - 그룹 내 비율이나 분포 계산 함수
        - CUME_DIST, PERCENT_RANK, NTILE, RATIO_TO_REPORT
    - **통계 및 선형 분석 함수**
        - 상관관계, 표준편차 등 통계 계산에 쓰이는 함수
        - 지원 DBMS마다 다름

<br>

### 사용 이유

- 복잡한 집계, 분석을 더 간단하고 효율적으로 실행 가능
- 원본 데이터 행 수 유지하며 집계 값 확인 가능
- 서브 쿼리나 복잡한 조인 없이 한 쿼리 내에서 다양한 분석 가능
- 행 간 비교 중심의 복잡한 분석에 강점 있음

<br>

## EXISTS vs IN

### exists vs in

| **구분**      | **EXISTS**                                                                                          | **IN**                                                  |
| ------------- | --------------------------------------------------------------------------------------------------- | ------------------------------------------------------- |
| **용도**      | 서브쿼리 결과의 존재 유무 판단 <br> 주 테이블 값과 비교해 서브쿼리에 포함되는지 판단할 때 주로 사용 | 특정 값이 집합/서브쿼리 결과에 포함되는지 확인          |
| **동작 방식** | 메인 쿼리의 각 행마다 서브쿼리 실행, <br> 조건 만족하면 TRUE, 즉시 평가 종료(쇼트서킷)              | IN 리스트 전체(서브쿼리 결과 포함)에 대해 값을 비교     |
| **NULL 처리** | NULL 값이 있어도 정상적으로 처리 <br> 조건만 맞으면 TRUE                                            | NULL이 포함된 경우(특히 NOT IN) 올바르지 않은 결과 가능 |
| **사용 예**   | WHERE EXISTS (SELECT ...)                                                                           | WHERE id IN (SELECT ...)                                |
| **비교 대상** | 값의 존재만 체크(값 반환 X)                                                                         | 동일 값 집합 내 존재 여부 직접 비교                     |

<br>

### IN, NOT IN 동작 방식

- **IN 동작 방식**
    - 컬럼의 값이 주어진 값 list or 서브쿼리 결과에 하나라도 포함되면 TRUE
    - IN절 내부적으로 OR 연산자로 처리
    - IN 리스트에 NULL 있더라도 NULL과 비교는 FALSE로 처리해 NULL 값인 행은 포함 X
    - 예시
        
        ```sql
        WHERE column IN (1, 2, NULL)
        
        WHERE column = 1 OR column = 2 OR column = NULL
        ```
        

- **NOT IN 동작 방식**
    - 컬럼의 값이 주어진 값 list or 서브쿼리 결과에 하나도 포함되지 않을 때 TRUE
    - NOT IN절 내부적으로 AND 연산자로 처리
    - NOT IN 리스트에 NULL 포함되면 UNKNOWN 상태되어 결과 전혀 반환되지 않음
    - 예시
        
        ```sql
        WHERE column NOT IN (1, 2, NULL)
        
        WHERE column != 1 AND column != 2 AND column != NULL
        ```
        
    
- **IN절에 NULL 있는 경우**
    - **`IN (100, NULL)`**
    - NULL은 “값이 없음” 의미해 어떤 값과 비교 불가능
    - NULL 값 가진 행은 비교에서 조건 만족하지 않는 것으로 취급
    - 따라서 NULL 값 나온 행이 조회되지 않음

- **NOT IN절에 NULL 있는 경우**
    - **`NOT IN (100, NULL, 40)`**
    - NULL과 비교한 것과 AND해 결과가 모두 UNKNOWN으로 평가됨
    - 따라서 아무 행도 반환되지 않는 문제 발생

<br>

### 성능 비교

- **서브쿼리 결과가 적을 때**
    - IN이 EXISTS보다 빠를 수 있음.
    - IN절은 서브쿼리 결과를 미리 메모리상에 리스트로 만들어두고 이 리스트에 대해 컬럼 값을 OR 조건으로 빠르게 비교.
    - EXISTS절은 메인 쿼리의 각 행마다 서브쿼리 실행해 조건 확인하는 방식이라 서브쿼리 반복 실행 때문에 느릴 수 있음.

- **서브쿼리 결과가 많을 때**
    - EXISTS가 IN 대비 더 빠른 경향이 있음.
    - EXISTS는 처음 TRUE 되는 순간 검색을 멈춰 빠름.
    - IN은 전체 결과를 모아서 비교하기 때문에 느림.

- **하나의 값만 검사**
    - IN이 간단하고 자연스러움
    - 단일 값 IN 절은 대부분 DBMS에서 ’**=** 연산자’와 동일하게 최적화해 성능 이슈도 없고, 단순 명료

- **컬럼이 인덱싱된 경우**
    - EXISTS가 더 효율적으로 동작 가능
    - EXISTS 내부 서브쿼리가 INDEX 생성된 컬럼을 이용해 조건에 맞는 첫 번째 행을 빠르게 찾으면 곧바로 탐색 종료하기 때문
    - INDEX는 서브쿼리의 컬럼에 걸려 있는 것
    - 원래는 메인 테이블의 컬럼 값이 1001 이라면 서브 쿼리 결과에서 컬럼 값이 1001인 것을 full table scan으로 찾던 것
    - 하지만 서브 쿼리의 컬럼에 index가 걸려 있다면 1001인 것 빠르게 찾을 수 있어 성능 향상되는 것
    - u.id가 1001인 것을 서브 쿼리에서 찾는데 o.user_id에 인덱스 걸려 있어 1001인 것 빠르게 찾는다는 의미
        
        ```sql
        SELECT *
        FROM users u
        WHERE EXISTS (
          SELECT 1
          FROM orders o
          WHERE o.user_id = u.id AND o.status = 'pending'
        );
        ```
        
<br>

### 요약

| **상황/목적**           | **추천 구문** | **이유**                          |
| ----------------------- | ------------- | --------------------------------- |
| 적은 건수(리스트, 결과) | IN            | 가독성, 단순함                    |
| 대량 데이터 비교        | EXISTS        | 빠른 존재성 체크(쇼트서킷)        |
| NULL 가능성 있는 경우   | EXISTS        | IN/NOT IN의 NULL로 인한 오류 방지 |
| 인덱스 활용 중요        | EXISTS        | 서브쿼리 인덱스 활용 가능         |

<br>

## LIKE

### LIKE란?

LIKE 연산자는 SELECT, UPDATE, DELETE 등에서 `문자열 패턴 매칭에 사용`

<br>

### LIKE 패턴 검색이 성능 문제 일으키는 이유

- **`전체 테이블 스캔 발생 (INDEX 사용 제한)`**
    - **`LIKE ‘%pattern’`** 이처럼 패턴 앞부분에 % 있는 경우 문제
    - %가 0개 이상의 임의 문자
    - 데이터베이스는 해당 컬럼의 모든 값 다 확인해야 해서 INDEX 활용 X
    - 따라서 테이블 전체 탐색 발생해 성능 저하

- **`복잡한 문자 비교`**
    - 단순 문자 비교가 아닌 문자 인코딩, 대소문자, 정렬(Collation) 정책까지 복합적으로 작용하여 비교 연산 비용이 증가

- **`데이터 볼륨과 패턴 복잡도`**
    - 테이블에 데이터 양이 많은 경우
    - 패턴이 매우 복잡한 경우
    - 이런 경우인데 자주 패턴 검색이 실행되면 전체적인 쿼리 성능 저하로 이어짐

<br>

### 성능 개선 방법

- **`패턴 앞에 % 피하기`**
    - **`LIKE ‘abc%’`** 가급적 이처럼 고정 prefix 검색 작성
    - 이 경우 INDEX가 효율적으로 사용됨

- **`Full-Text INDEX or 전문 검색 엔진 활용`**
    - 만약 ‘%pattern’ 형태 반드시 필요한 경우
    - 전문 검색 엔진 활용해 빠른 검색 가능하게 하자
    - ex
        - SQL Server의 Full-Text Index
        - MySQL의 Fulltext
        - 외부의 Elasticsearch

- **`REGEXP_LIKE 등 더 복잡한 패턴 처리 문법 활용`**
    - LIKE 절로는 표현하기 어려운 복잡한 패턴 검색을 가능하게 해주는 정규식 기반 패턴 매칭 함수
    - 주요 DBMS에서 지원
    - 다양한 문자 패턴 검색, 대소문자 처리, 특수문자 및 반복·선택 등과 관련된 쿼리 최적화에 활용

- **`바이너리 Collation 활용`**
    - SQL Server는 **`COLLATE`** 구문을 활용해 바이너리 비교로 성능 향상 가능
    - 바이트 단위로 검색하게 되어 문자열 비교 불필요 작업 줄어듬

- **`plus`**
    - 성능에 민감한 서비스라면, 단순 LIKE 검색 대신 구체적 구조 개선과 검색 전문화 전략을 도입

<br>

### 기타 주의할 점

- **대소문자 구분**
    - 데이터베이스에 따라 대소문자 구분 여부가 다름
    - 원하는 결과 나오지 않으면 COLLATE, UPPDER, LOVWER 함수 활용

- **와일드카드 등 특수문자 사용**
    - %, _ 문자 자체 검색하려면 ESCAPE 옵션 or 이스케이프 문자 사용

- **NULL 값 주의**
    - LIKE는 NULL에 대해 항상 UNKOWN 반환
    - 패턴 매칭 조건 사용 시 NOT NULL 조건과 함께 사용 필요할 수 있음

- **유니코드와 인코딩**
    - 한글, 중국어 등 다국어에서는 인코딩, 정렬 정책 영향으로 패턴 의도한대로 동작하지 않는 경우 있음